ğŸ“Œ Problem Statement
A system that allows users to split expenses with friends and track who owes whom. Designed to support group-based expense management like trips, events, or shared purchases.

âœ… Core Functional Requirements
User registration & login

Create and name expense groups (e.g., â€œGoa Tripâ€)

Invite friends to groups

Add expenses within a group, with split logic (equal, percentage, etc.)

Calculate who owes how much to whom

Send payment reminders

Settle debts

âš™ï¸ Class Design
User
class User {
  string userId;
  string name;
  string email;
  string picture; // base64 or URL
  List<string> friendList; // List of userIds
  Map<string, UserStats> statsPerGroup; // key: splitId

  // Optional precomputed summary for dashboard
  int totalMoneyBorrowed;
  int totalMoneyLent;
}
ğŸ”¹ UserStats is a light summary class holding balance info per group
ğŸ”¹ We use a Map<splitId, stats> instead of all transactions in the user directly

SplitGroup (aka SplitInfo)

class SplitGroup {
  string splitId;
  string splitName;
  CurrencyEnum currency;
  Date createdDate;
  string createdBy; // userId
  List<string> members; // userIds
  List<Expense> expenses;
  List<Transaction> transactions;
}
ğŸ”¹ Transaction is the new name for moneyCalculations
ğŸ”¹ Group now owns the source of truth for transactions

Expense
class Expense {
  string expenseId;
  string name;
  int amount;
  string addedBy; // userId
  string paidBy; // userId
  string groupId;
  ExpenseState state; // e.g., PENDING, SETTLED
}
Transaction
ts
Copy
Edit
class Transaction {
  string transactionId;
  string fromUserId;
  string toUserId;
  int amount;
  string expenseId;
  string groupId;
}
ğŸ”¹ Clear debt direction: A â†’ owes â†’ B
ğŸ”¹ One transaction = one directional obligation

UserStats (Light summary per group for quick dashboard)

class UserStats {
  int totalOwed;
  int totalLent;
  List<Transaction> myTransactions;
}
ğŸ”— Relationships Recap
1 SplitGroup â†’ many Users

1 SplitGroup â†’ many Expenses

1 Expense â†’ many Transactions

1 User â†’ many SplitGroups (via statsPerGroup)

1 User â†’ many Transactions

ğŸ¯ Design Patterns Used

State Machine on Expense.state to enforce legal transitions (Pending â†’ Settled)

(Optional) Observer could notify users after a new expense is added (currently handled by JS events / message queue)

MVC Layering:

Controllers (REST interface)

Services (Business logic)

Models (Entity classes above)

ğŸ§  Services Layer
ExpenseService
addExpense(userId, groupId, ExpensePayload)

calculateSplit(Expense)

getExpensesByGroup(groupId)

settleExpense(expenseId)

GroupService
createGroup(userId, groupName)

addUserToGroup(groupId, userId)

getGroupSummary(groupId)

UserService
registerUser(payload)

getDashboard(userId)

getFriendList(userId)

TransactionService
getBalanceSheet(userId)

getTransactions(groupId)

sendReminder(groupId, userId)

ğŸ“Š Data Flow
text
Copy
Edit
User registers â†’
  Creates SplitGroup â†’
    Invites members â†’
      Adds expense â†’
        System calculates split â†’
          Transactions created â†’
            User stats updated â†’
              Optionally: reminders sent to others
ğŸ’¡ Edge Cases (Handled or Acknowledged)
User canâ€™t leave group until settled

Only group creator can delete group or expenses

Partial payments not supported yet â€” workaround via new micro-split groups

Duplicate user in group avoided at creation

No negative expense amounts allowed

Group/expense/transaction modification requires role-based access control

ğŸ” Optional Enhancements (For Future)
Credit scoring layer on top of user stats

Gamified achievements (Observer would be great here)

Push/email reminders using background job workers

Full audit log of state transitions (FSM logs)